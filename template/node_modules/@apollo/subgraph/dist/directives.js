"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.directiveDefinitionsAreCompatible = exports.typeIncludesDirective = exports.gatherDirectives = exports.isFederationDirective = exports.federationDirectives = exports.OverrideDirective = exports.InaccessibleDirective = exports.LinkDirective = exports.ShareableDirective = exports.TagDirective = exports.ProvidesDirective = exports.RequiresDirective = exports.ExternalDirective = exports.ExtendsDirective = exports.KeyDirective = void 0;
const graphql_1 = require("graphql");
const types_1 = require("./types");
exports.KeyDirective = new graphql_1.GraphQLDirective({
    name: 'key',
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.INTERFACE],
    args: {
        fields: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
        },
        resolvable: {
            type: graphql_1.GraphQLBoolean,
            defaultValue: true
        }
    },
});
exports.ExtendsDirective = new graphql_1.GraphQLDirective({
    name: 'extends',
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.INTERFACE],
});
exports.ExternalDirective = new graphql_1.GraphQLDirective({
    name: 'external',
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.FIELD_DEFINITION],
});
exports.RequiresDirective = new graphql_1.GraphQLDirective({
    name: 'requires',
    locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
    args: {
        fields: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
        },
    },
});
exports.ProvidesDirective = new graphql_1.GraphQLDirective({
    name: 'provides',
    locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
    args: {
        fields: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
        },
    },
});
exports.TagDirective = new graphql_1.GraphQLDirective({
    name: 'tag',
    locations: [
        graphql_1.DirectiveLocation.FIELD_DEFINITION,
        graphql_1.DirectiveLocation.OBJECT,
        graphql_1.DirectiveLocation.INTERFACE,
        graphql_1.DirectiveLocation.UNION,
        graphql_1.DirectiveLocation.ARGUMENT_DEFINITION,
        graphql_1.DirectiveLocation.SCALAR,
        graphql_1.DirectiveLocation.ENUM,
        graphql_1.DirectiveLocation.ENUM_VALUE,
        graphql_1.DirectiveLocation.INPUT_OBJECT,
        graphql_1.DirectiveLocation.INPUT_FIELD_DEFINITION,
    ],
    isRepeatable: true,
    args: {
        name: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
        },
    },
});
exports.ShareableDirective = new graphql_1.GraphQLDirective({
    name: 'shareable',
    locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION, graphql_1.DirectiveLocation.OBJECT],
});
exports.LinkDirective = new graphql_1.GraphQLDirective({
    name: 'link',
    locations: [graphql_1.DirectiveLocation.SCHEMA],
    args: {
        url: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
        },
        import: {
            type: new graphql_1.GraphQLList(types_1.LinkImportType),
        }
    },
});
exports.InaccessibleDirective = new graphql_1.GraphQLDirective({
    name: 'inaccessible',
    locations: [
        graphql_1.DirectiveLocation.FIELD_DEFINITION,
        graphql_1.DirectiveLocation.OBJECT,
        graphql_1.DirectiveLocation.INTERFACE,
        graphql_1.DirectiveLocation.UNION,
        graphql_1.DirectiveLocation.ARGUMENT_DEFINITION,
        graphql_1.DirectiveLocation.SCALAR,
        graphql_1.DirectiveLocation.ENUM,
        graphql_1.DirectiveLocation.ENUM_VALUE,
        graphql_1.DirectiveLocation.INPUT_OBJECT,
        graphql_1.DirectiveLocation.INPUT_FIELD_DEFINITION,
    ],
});
exports.OverrideDirective = new graphql_1.GraphQLDirective({
    name: 'override',
    locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
    args: {
        from: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString),
        },
    },
});
exports.federationDirectives = [
    exports.KeyDirective,
    exports.ExtendsDirective,
    exports.ExternalDirective,
    exports.RequiresDirective,
    exports.ProvidesDirective,
    exports.ShareableDirective,
    exports.LinkDirective,
    exports.TagDirective,
    exports.InaccessibleDirective,
    exports.OverrideDirective,
];
function isFederationDirective(directive) {
    return exports.federationDirectives.some(({ name }) => name === directive.name);
}
exports.isFederationDirective = isFederationDirective;
function hasDirectives(node) {
    return Boolean('directives' in node && node.directives);
}
function gatherDirectives(element) {
    const directives = [];
    if ('extensionASTNodes' in element && element.extensionASTNodes) {
        for (const node of element.extensionASTNodes) {
            if (hasDirectives(node)) {
                directives.push(...node.directives);
            }
        }
    }
    if (element.astNode && hasDirectives(element.astNode))
        directives.push(...element.astNode.directives);
    return directives;
}
exports.gatherDirectives = gatherDirectives;
function typeIncludesDirective(type, directiveName) {
    const directives = gatherDirectives(type);
    return directives.some((directive) => directive.name.value === directiveName);
}
exports.typeIncludesDirective = typeIncludesDirective;
function directiveDefinitionsAreCompatible(baseDefinition, toCompare) {
    var _a, _b, _c, _d;
    if (baseDefinition.name.value !== toCompare.name.value)
        return false;
    if (((_a = baseDefinition.arguments) === null || _a === void 0 ? void 0 : _a.length) !== ((_b = toCompare.arguments) === null || _b === void 0 ? void 0 : _b.length)) {
        return false;
    }
    for (const arg of (_c = baseDefinition.arguments) !== null && _c !== void 0 ? _c : []) {
        const toCompareArg = (_d = toCompare.arguments) === null || _d === void 0 ? void 0 : _d.find((a) => a.name.value === arg.name.value);
        if (!toCompareArg)
            return false;
        if ((0, graphql_1.print)(stripDescriptions(arg)) !== (0, graphql_1.print)(stripDescriptions(toCompareArg))) {
            return false;
        }
    }
    if (toCompare.locations.some((location) => !baseDefinition.locations.find((baseLocation) => baseLocation.value === location.value))) {
        return false;
    }
    return true;
}
exports.directiveDefinitionsAreCompatible = directiveDefinitionsAreCompatible;
function stripDescriptions(astNode) {
    return (0, graphql_1.visit)(astNode, {
        enter(node) {
            return 'description' in node ? { ...node, description: undefined } : node;
        },
    });
}
//# sourceMappingURL=directives.js.map