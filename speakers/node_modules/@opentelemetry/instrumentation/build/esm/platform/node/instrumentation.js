/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import * as path from 'path';
import * as RequireInTheMiddle from 'require-in-the-middle';
import { satisfies } from 'semver';
import { InstrumentationAbstract } from '../../instrumentation';
import { diag } from '@opentelemetry/api';
/**
 * Base abstract class for instrumenting node plugins
 */
var InstrumentationBase = /** @class */ (function (_super) {
    __extends(InstrumentationBase, _super);
    function InstrumentationBase(instrumentationName, instrumentationVersion, config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;
        _this._hooks = [];
        _this._enabled = false;
        var modules = _this.init();
        if (modules && !Array.isArray(modules)) {
            modules = [modules];
        }
        _this._modules = modules || [];
        if (_this._modules.length === 0) {
            diag.warn('No modules instrumentation has been defined,' +
                ' nothing will be patched');
        }
        if (_this._config.enabled) {
            _this.enable();
        }
        return _this;
    }
    InstrumentationBase.prototype._extractPackageVersion = function (baseDir) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            var version = require(path.join(baseDir, 'package.json')).version;
            return typeof version === 'string' ? version : undefined;
        }
        catch (error) {
            diag.warn('Failed extracting version', baseDir);
        }
        return undefined;
    };
    InstrumentationBase.prototype._onRequire = function (module, exports, name, baseDir) {
        var _a;
        if (!baseDir) {
            if (typeof module.patch === 'function') {
                module.moduleExports = exports;
                return module.patch(exports);
            }
            return exports;
        }
        var version = this._extractPackageVersion(baseDir);
        module.moduleVersion = version;
        if (module.name === name) {
            // main module
            if (isSupported(module.supportedVersions, version, module.includePrerelease)) {
                if (typeof module.patch === 'function') {
                    module.moduleExports = exports;
                    if (this._enabled) {
                        return module.patch(exports, module.moduleVersion);
                    }
                }
            }
        }
        else {
            // internal file
            var files = (_a = module.files) !== null && _a !== void 0 ? _a : [];
            var file = files.find(function (f) { return f.name === name; });
            if (file && isSupported(file.supportedVersions, version, module.includePrerelease)) {
                file.moduleExports = exports;
                if (this._enabled) {
                    return file.patch(exports, module.moduleVersion);
                }
            }
        }
        return exports;
    };
    InstrumentationBase.prototype.enable = function () {
        var _this = this;
        if (this._enabled) {
            return;
        }
        this._enabled = true;
        // already hooked, just call patch again
        if (this._hooks.length > 0) {
            for (var _i = 0, _a = this._modules; _i < _a.length; _i++) {
                var module_1 = _a[_i];
                if (typeof module_1.patch === 'function' && module_1.moduleExports) {
                    module_1.patch(module_1.moduleExports, module_1.moduleVersion);
                }
                for (var _b = 0, _c = module_1.files; _b < _c.length; _b++) {
                    var file = _c[_b];
                    if (file.moduleExports) {
                        file.patch(file.moduleExports, module_1.moduleVersion);
                    }
                }
            }
            return;
        }
        var _loop_1 = function (module_2) {
            this_1._hooks.push(RequireInTheMiddle([module_2.name], { internals: true }, function (exports, name, baseDir) {
                return _this._onRequire(module_2, exports, name, baseDir);
            }));
        };
        var this_1 = this;
        for (var _d = 0, _e = this._modules; _d < _e.length; _d++) {
            var module_2 = _e[_d];
            _loop_1(module_2);
        }
    };
    InstrumentationBase.prototype.disable = function () {
        if (!this._enabled) {
            return;
        }
        this._enabled = false;
        for (var _i = 0, _a = this._modules; _i < _a.length; _i++) {
            var module_3 = _a[_i];
            if (typeof module_3.unpatch === 'function' && module_3.moduleExports) {
                module_3.unpatch(module_3.moduleExports, module_3.moduleVersion);
            }
            for (var _b = 0, _c = module_3.files; _b < _c.length; _b++) {
                var file = _c[_b];
                if (file.moduleExports) {
                    file.unpatch(file.moduleExports, module_3.moduleVersion);
                }
            }
        }
    };
    InstrumentationBase.prototype.isEnabled = function () {
        return this._enabled;
    };
    return InstrumentationBase;
}(InstrumentationAbstract));
export { InstrumentationBase };
function isSupported(supportedVersions, version, includePrerelease) {
    if (typeof version === 'undefined') {
        // If we don't have the version, accept the wildcard case only
        return supportedVersions.includes('*');
    }
    return supportedVersions.some(function (supportedVersion) {
        return satisfies(version, supportedVersion, { includePrerelease: includePrerelease });
    });
}
//# sourceMappingURL=instrumentation.js.map