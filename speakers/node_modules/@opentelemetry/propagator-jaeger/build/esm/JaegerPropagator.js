/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { propagation, trace, TraceFlags, } from '@opentelemetry/api';
import { isTracingSuppressed } from '@opentelemetry/core';
export var UBER_TRACE_ID_HEADER = 'uber-trace-id';
export var UBER_BAGGAGE_HEADER_PREFIX = 'uberctx';
var UBER_BAGGAGE_HEADER_REGEX = /^uberctx-(.+)/i;
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 * {trace-id}:{span-id}:{parent-span-id}:{flags}
 * {trace-id}
 * 64-bit or 128-bit random number in base16 format.
 * Can be variable length, shorter values are 0-padded on the left.
 * Value of 0 is invalid.
 * {span-id}
 * 64-bit random number in base16 format.
 * {parent-span-id}
 * Set to 0 because this field is deprecated.
 * {flags}
 * One byte bitmap, as two hex digits.
 * Inspired by jaeger-client-node project.
 */
var JaegerPropagator = /** @class */ (function () {
    /**
     * @param {string} [customTraceHeader="uber-trace-id"] - HTTP header to inject\extract trace from.
     **/
    function JaegerPropagator(customTraceHeader) {
        this._jaegerTraceHeader = customTraceHeader || UBER_TRACE_ID_HEADER;
    }
    JaegerPropagator.prototype.inject = function (context, carrier, setter) {
        var spanContext = trace.getSpanContext(context);
        var baggage = propagation.getBaggage(context);
        if (spanContext && isTracingSuppressed(context) === false) {
            var traceFlags = "0" + (spanContext.traceFlags || TraceFlags.NONE).toString(16);
            setter.set(carrier, this._jaegerTraceHeader, spanContext.traceId + ":" + spanContext.spanId + ":0:" + traceFlags);
        }
        if (baggage) {
            for (var _i = 0, _a = baggage.getAllEntries(); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], entry = _b[1];
                setter.set(carrier, UBER_BAGGAGE_HEADER_PREFIX + "-" + key, encodeURIComponent(entry.value));
            }
        }
    };
    JaegerPropagator.prototype.extract = function (context, carrier, getter) {
        var _a;
        var uberTraceIdHeader = getter.get(carrier, this._jaegerTraceHeader);
        var uberTraceId = Array.isArray(uberTraceIdHeader)
            ? uberTraceIdHeader[0]
            : uberTraceIdHeader;
        var baggageValues = getter
            .keys(carrier)
            .filter(function (key) { return UBER_BAGGAGE_HEADER_REGEX.test(key); })
            .map(function (key) {
            var value = getter.get(carrier, key);
            return {
                key: key.substring(UBER_BAGGAGE_HEADER_PREFIX.length + 1),
                value: Array.isArray(value) ? value[0] : value,
            };
        });
        var newContext = context;
        // if the trace id header is present and valid, inject it into the context
        if (typeof uberTraceId === 'string') {
            var spanContext = deserializeSpanContext(uberTraceId);
            if (spanContext) {
                newContext = trace.setSpanContext(newContext, spanContext);
            }
        }
        if (baggageValues.length === 0)
            return newContext;
        // if baggage values are present, inject it into the current baggage
        var currentBaggage = (_a = propagation.getBaggage(context)) !== null && _a !== void 0 ? _a : propagation.createBaggage();
        for (var _i = 0, baggageValues_1 = baggageValues; _i < baggageValues_1.length; _i++) {
            var baggageEntry = baggageValues_1[_i];
            if (baggageEntry.value === undefined)
                continue;
            currentBaggage = currentBaggage.setEntry(baggageEntry.key, {
                value: decodeURIComponent(baggageEntry.value),
            });
        }
        newContext = propagation.setBaggage(newContext, currentBaggage);
        return newContext;
    };
    JaegerPropagator.prototype.fields = function () {
        return [this._jaegerTraceHeader];
    };
    return JaegerPropagator;
}());
export { JaegerPropagator };
/**
 * @param {string} serializedString - a serialized span context.
 * @return {SpanContext} - returns a span context represented by the serializedString.
 **/
function deserializeSpanContext(serializedString) {
    var headers = decodeURIComponent(serializedString).split(':');
    if (headers.length !== 4) {
        return null;
    }
    var _traceId = headers[0], spanId = headers[1], flags = headers[3];
    var traceId = _traceId.padStart(32, '0');
    var traceFlags = flags.match(/^[0-9a-f]{2}$/i) ? parseInt(flags) & 1 : 1;
    return { traceId: traceId, spanId: spanId, isRemote: true, traceFlags: traceFlags };
}
//# sourceMappingURL=JaegerPropagator.js.map